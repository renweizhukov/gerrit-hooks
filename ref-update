#!/usr/bin/env python
# -*- Coding: utf-8 -*-
#
#   Copyright (c) 2016      Wei Ren <renwei@smartconn.cc>
#
# This is a simple Gerrit server hook for checking the commit messages being pushed to Gerrit.  
# If any commit message doesn't meet one of the four requirements below, the push will be rejected:
# (1) The commit message should conform to the following template:
####################################################
# <commit message title>  
#
# This commit fixes/refs #123, refs #456, and refs #789.
# < FOR INFORMATION ONLY! PLEASE DELETE THIS!
# Note that if you claims that this commit fixes an issue, submitting this commit will resolve the issue as Fixed. 
# Thus if you plan to fix one issue with more than one commit, please only use the keyword "fixes" for the last commit.
# FOR INFORMATION ONLY! PLEASE DELETE THIS!> 
#
# <code change short description>
#
# HOW BUILT
# <how did you build this code change>
#
# HOW VERIFIED
# <how did you verify this code change>
#
# Change-Id: I214325432654654adf324325432ec32435435456
# Signed-off-by: John Doe <johndoe@company.com>
####################################################
# Note that the Change-Id and Signed-off-by are generated by git commit-msg hook and git 
# commit option '-s', respectively.
# (2) The length of the commit message title should not be greater than 100 characters.
# (3) The fixed/referenced issue ID(s) should be mentioned in the second paragraph. 
# (4) The fixed/referenced issue ID(s) should belong to the redmine project linked to the gerrit project.
# Script has been tested with Gerrit 2.11.4 and 2.12.2.

import optparse
from subprocess import check_output # You'll need python 2.7 for this
import sys
import re
from redmine import Redmine

# This regular expression will be used to match the above commit message template:
# Note that the regular expression '^tree.+\nparent.+\nauthor.+\ncommitter.+\n\n' before  
# the first match group is to match the message headers automatically added by "git cat-file commit":
# tree SHA-1
# parent SHA-1
# parent SHA-1 (optional: if this is a merge commit, it will have two parent commits)
# author John Doe <johndoe@company.com> 1460709478 -0700
# committer John Doe <johndoe@company.com> 1460709478 -0700
COMMIT_MSG_TEMPLATE_REGEX = '^tree.+\n(?:parent.+\n){1,2}author.+\ncommitter.+\n\n(.+?)\n\n(This commit .+\n)[\w\W]+HOW BUILT\n[\w\W]+HOW VERIFIED\n[\w\W]+(?:(?:Change-Id: .+\n+Signed-off-by: .+)|(?:Signed-off-by: .+\n+Change-Id: .+))$'
# This regular expression will be used to match the fixed/referenced issue(s) mentioned 
# in the second paragraph of the commit message.
COMMIT_MSG_ISSUE_REGEX = '(?:fixes|refs) \#(\d+)'

MAX_MSG_TITLE = 100

# We have an exception for the revert commit generated by gerrit. The revert commit 
# message usually follows the format as below:
####################################################
# Revert "Test blocking the zero issue ID."

# This reverts commit 67a1da6239e8e321fd5eebc8af015efca85060b8.
####################################################
REVERT_COMMIT_MSG_TEMPLATE_REGEX = 'Revert ".+"\n\nThis reverts commit [\da-fA-F]+.'

# The prefix of the reference name of a push which may create/delete a tag.
# If the push is related to tags, it won't go through the commit message format check.
TAG_REFERENCE_PREFIX = 'refs/tags/'

# The prefix of the reference name of a push which may create/delete a branch. 
# Note that 
# (1) This prefix is actually the same as the prefix of the reference name of a commit directly pushed to the git repository which  
# bypasses the gerrit code review. Also remotely deleting a branch is dangerous and can lead to some unexpected consequences, so we  
# don't enable the prefix of the branch reference name. 
# (2) Even if we enable the prefix of the branch reference name, only the gerrit users with the "Force Push" permission for the 
# reference "refs/heads/*" will be able to remotely delete a branch.
# BRANCH_REFERENCE_PREFIX = 'refs/heads/'

# The list of all projects to run the script for
GERRIT_PROJECTS = ["Gerrit-Project-Name"]

# The dictionary of gerrit-projects-to-redmine-projects. The key is a gerrit project which can be a regular expression
# and the value is a list of redmine project identifiers which are linked to the gerrit project.
GERRIT_REDMINE_PROJECT_DICT = {'Gerrit-Project-Name', ['Redmine-Project-Identifier-List']}

# Print out the gerrit administrator's contact info if there is an error.
GERRIT_ADMIN_CONTACT_MSG = 'If you hit an unexpected error, please contact the gerrit administrator renwei@smartconn.cc.'

# Connect to our redmine server.
redmine = Redmine('Redmine-URL', key='Redmine-API-Key')

def IsRevertCommit(revertCommitPattern, commitMsg):
    templateMatch = re.search(revertCommitPattern, commitMsg, re.IGNORECASE)
    if templateMatch:
        return True
    else:
        return False
        
def IsValidIssue(issueId, gerritProject):
    # Get the list of redmine projects linked to the given gerrit project.
    redmineProjectList = None
    for gProject in GERRIT_REDMINE_PROJECT_DICT.keys():
        if re.match(gProject, gerritProject):
            redmineProjectList = GERRIT_REDMINE_PROJECT_DICT[gProject]

    # Check each redmine project and see if it has one such issue.
    if redmineProjectList != None:
        for redmineProjectName in redmineProjectList:
            redmineProject = redmine.project.get(redmineProjectName)
            targetIssue = redmineProject.issues.get(int(issueId), None) # issueId is a string.
            if targetIssue != None:
                print "This issue {0} belongs to the linked redmine project {1}.".format(issueId, redmineProjectName)
                return True

        print "This issue {0} doesn't belong to any redmine project linked to the gerrit project {1}!!".format(issueId, gerritProject)
        return False
    else:
        print "This gerrit project {0} doesn't have a linked redmine project!!".format(gerritProject)
        return False

def CheckCommitMsg(templatePattern, issuePattern, commitMsg, gerritProject):
    templateMatch = re.match(templatePattern, commitMsg, re.IGNORECASE)
    if templateMatch:
        # Check if the length of the message title is not greater than MAX_MSG_TITLE characters.
        titleParagraph = templateMatch.group(1)
        if len(titleParagraph) > MAX_MSG_TITLE:
            print 'This commit message title is too long (> {0:d}).'.format(MAX_MSG_TITLE)
            return False
        
        # Check if the fixed/referenced issue is mentioned in the second paragraph 
        # the commit message.
        issueParagraph = templateMatch.group(2)
        refIssueIds = re.findall(issuePattern, issueParagraph, re.IGNORECASE)
        if not refIssueIds:
            print 'This commit message doesn\'t mention any fixed/referenced issue in the second paragraph.'
            return False
        else:
            # Check each issue ID fixed/referenced in the commit message.
            for issueId in refIssueIds:
                print 'This commit fixes/refs issue', issueId
                if not IsValidIssue(issueId, gerritProject):
                    return False
            return True
    else:
        print 'This commit message doesn\'t conform to the template.'
        return False

if __name__ == '__main__':
    # This ref-update hook is called by Gerrit in the following format:
    # ref-update --project <project name> --refname <refname> --uploader <uploader> --oldrev <sha1> --newrev <sha1>
    
    # Parse the hook invoking options.
    parser = optparse.OptionParser()
    parser.add_option('-p', '--project', dest='project')
    parser.add_option('-r', '--refname', dest='refname')
    parser.add_option('-u', '--uploader', dest='uploader')
    parser.add_option('-o', '--oldrev', dest='oldrev')
    parser.add_option('-n', '--newrev', dest='newrev')
    
    (options, x) = parser.parse_args(sys.argv)
    
    print 'The refname is {0}.'.format(options.refname)

    if options.project not in GERRIT_PROJECTS:
        print 'The commit message check is not required for project {0}.'.format(options.project)
        sys.exit(0)

    if options.refname.startswith(TAG_REFERENCE_PREFIX):
        tagName = options.refname[len(TAG_REFERENCE_PREFIX):]
        print 'The commit message check is not required for changing the tag {1} of project {0}.'.format(options.project, tagName)
        sys.exit(0)

    #if options.refname.startswith(BRANCH_REFERENCE_PREFIX):
    #    branchName = options.refname[len(BRANCH_REFERENCE_PREFIX):]
    #    print 'The commit message format check is not required for changing the branch {1} of project {0}.'.format(options.project, branchName)
    #    sys.exit(0)

    # Get the SHA-1s of all commits included in this push as one string.
    if int(options.oldrev, 16) != 0:
        commitStr = check_output(['git', 'rev-list', options.oldrev + '..' + options.newrev])
    else:
        # According to https://groups.google.com/forum/#!topic/repo-discuss/Rw_t-jP7X1M, oldrev is always 0,
        # so "git rev-list oldrev..newrev" will always fail. In this case, "git rev-list newrev --not --branches=*"
        # will list all the new commits included in this push.
        commitStr = check_output(['git', 'rev-list', options.newrev, '--not', '--branches=*'])
    # Split the above string into a list of commit's SHA-1s.
    commits = commitStr.split()
    
    # Check the commit messages one by one.
    checkPassed = True
    for commit in commits:  
        commitMsg = check_output(['git', 'cat-file', 'commit', commit])

        print 'Checking if this is a revert commit {0} for project {1}.'.format(commit, options.project)
        # If this is a revert commit, only skip the message format check for this commit.
        if IsRevertCommit(REVERT_COMMIT_MSG_TEMPLATE_REGEX, commitMsg):
            print 'This is a revert commit {0} for project {1}, so skip the commit message check.'.format(commit, options.project)
            continue
        else:
            print 'This is not a revert commit {0} for project {1}.'.format(commit, options.project)
        
        print 'Checking the message of commit {0} for project {1}.'.format(commit, options.project)
        # If one commit message check fails, mark the entire test as failed but 
        # continue checking the remaining commit messages.
        if not CheckCommitMsg(COMMIT_MSG_TEMPLATE_REGEX, COMMIT_MSG_ISSUE_REGEX, commitMsg, options.project):
            checkPassed = False
        
    if checkPassed:
        print "The commit message check is passed for project {0}.".format(options.project)
        sys.exit(0)
    else:
        print "The commit message check fails for project {0}.".format(options.project)
        print GERRIT_ADMIN_CONTACT_MSG
        sys.exit(1)
