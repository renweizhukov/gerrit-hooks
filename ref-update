#!/usr/bin/env python
# -*- Coding: utf-8 -*-
#
#   Copyright (c) 2016      Wei Ren <renwei@smartconn.cc>

# This is a simple Gerrit server hook for checking the message format of the commits 
# being pushed to Gerrit. If any commit message doesn't meet one of the three requirements
# below, the push will be rejected:
# (1) The commit message should conform to the following template:
####################################################
# <commit message title>  
#
# This commit fixes #123, refs #456, and refs #789. 
#
# <code change short description>
#
# HOW BUILT
# <how did you build this code change>
#
# HOW VERIFIED
# <how did you verify this code change>
#
# Change-Id: I214325432654654adf324325432ec32435435456
# Signed-off-by: John Doe <johndoe@company.com>
####################################################
# Note that the Change-Id and Signed-off-by are generated by git commit-msg hook and 
# git commit option '-s', respectively.
# (2) The length of the commit message title should not be greater than 100 characters.
# (3) The fixed/referenced issue ID(s) should be mentioned in the second paragraph.
#
# Script is tested with Gerrit 2.11.4.

# This regular expression will be used to match the above commit message template:
# Note that the regular expression '^tree.+\nparent.+\nauthor.+\ncommitter.+\n\n' before  
# the first match group is to match the message headers automatically added by "git cat-file commit":
# tree SHA-1
# parent SHA-1
# parent SHA-1 (optional: if this is a merge commit, it will have two parent commits)
# author John Doe <johndoe@company.com> 1460709478 -0700
# committer John Doe <johndoe@company.com> 1460709478 -0700
COMMIT_MSG_TEMPLATE_REGEX = '^tree.+\n(?:parent.+\n){1,2}author.+\ncommitter.+\n\n(.+?)\n\n(This commit .+\n)[\w\W]+HOW BUILT\n[\w\W]+HOW VERIFIED\n[\w\W]+(?:(?:Change-Id: .+\n+Signed-off-by: .+)|(?:Signed-off-by: .+\n+Change-Id: .+))$'
# This regular expression will be used to match the fixed/referenced issue(s) mentioned 
# in the second paragraph of the commit message.
COMMIT_MSG_ISSUE_REGEX = '(?:fixes|refs) \#(\d+)'

MAX_MSG_TITLE = 100

# We have an exception for the revert commit generated by gerrit. The revert commit 
# message usually follows the format as below:
####################################################
# Revert "Test blocking the zero issue ID."

# This reverts commit 67a1da6239e8e321fd5eebc8af015efca85060b8.
####################################################
REVERT_COMMIT_MSG_TEMPLATE_REGEX = 'Revert ".+"\n\nThis reverts commit [\da-fA-F]+.'

# The list of all projects to run the script for
GERRIT_PROJECTS = ["Project-Name"]

import optparse
from subprocess import check_output # TODO: you'll need python 2.7 for this
import sys
import re

def IsRevertCommit(revertCommitPattern, commitMsg):
    templateMatch = re.search(revertCommitPattern, commitMsg, re.IGNORECASE)
    if templateMatch:
        return True
    else:
        return False

def CheckCommitMsgFormat(templatePattern, issuePattern, commitMsg):
    templateMatch = re.match(templatePattern, commitMsg, re.IGNORECASE)
    if templateMatch:
        # Check if the length of the message title is not greater than MAX_MSG_TITLE characters.
        titleParagraph = templateMatch.group(1)
        if len(titleParagraph) > MAX_MSG_TITLE:
            print 'This commit message title is too long (> {0:d}).'.format(MAX_MSG_TITLE)
            return False
        
        # Check if the fixed/referenced issue is mentioned in the second paragraph 
        # the commit message.
        issueParagraph = templateMatch.group(2)
        refIssueIds = re.findall(issuePattern, issueParagraph, re.IGNORECASE)
        if not refIssueIds:
            print 'This commit message doesn\'t mention any fixed/referenced issue in the second paragraph.'
            return False
        else:
            # Check each issue ID fixed/referenced in the commit message.
            for issueId in refIssueIds:
                print 'This commit fixes/refs issue', issueId
                if int(issueId) == 0:
                    print 'This commit message fixes/refs an invalid zero issue ID.'
                    return False
            return True
    else:
        print 'This commit message doesn\'t conform to the template.'
        return False

if __name__ == '__main__':
    # This ref-update hook is called by Gerrit in the following format:
    # ref-update --project <project name> --refname <refname> --uploader <uploader> --oldrev <sha1> --newrev <sha1>
    
    # Parse the hook invoking options.
    parser = optparse.OptionParser()
    parser.add_option('-p', '--project', dest='project')
    parser.add_option('-r', '--refname', dest='refname')
    parser.add_option('-u', '--uploader', dest='uploader')
    parser.add_option('-o', '--oldrev', dest='oldrev')
    parser.add_option('-n', '--newrev', dest='newrev')
    
    (options, x) = parser.parse_args(sys.argv)
    
    if options.project not in GERRIT_PROJECTS:
        print 'The commit message format check is not required for project {0}.'.format(options.project)
        sys.exit(0)
    
    # Get the SHA-1s of all commits included in this push as one string.
    if int(options.oldrev, 16) != 0:
        commitStr = check_output(['git', 'rev-list', options.oldrev + '..' + options.newrev])
    else:
        # According to https://groups.google.com/forum/#!topic/repo-discuss/Rw_t-jP7X1M, oldrev is always 0,
        # so "git rev-list oldrev..newrev" will always fail. In this case, "git rev-list newrev --not --branches=*"
        # will list all the new commits included in this push.
        commitStr = check_output(['git', 'rev-list', options.newrev, '--not', '--branches=*'])
    # Split the above string into a list of commit's SHA-1s.
    commits = commitStr.split()
    
    # Check the commit messages one by one.
    checkPassed = True
    for commit in commits:  
        commitMsg = check_output(['git', 'cat-file', 'commit', commit])
        
        print 'Checking if this is a revert commit {0} for project {1}.'.format(commit, options.project)
        # If this is a revert commit, only skip the message format check for this commit.
        if IsRevertCommit(REVERT_COMMIT_MSG_TEMPLATE_REGEX, commitMsg):
            print 'This is a revert commit {0} for project {1}, so skip the commit message check.'.format(commit, options.project)
            continue
        else:
            print 'This is not a revert commit {0} for project {1}.'.format(commit, options.project)
        
        print 'Checking the message format of commit {0} for project {1}.'.format(commit, options.project)
        # If one commit message check fails, mark the entire test as failed but 
        # continue checking the remaining commit messages.
        if not CheckCommitMsgFormat(COMMIT_MSG_TEMPLATE_REGEX, COMMIT_MSG_ISSUE_REGEX, commitMsg):
            checkPassed = False
        
    if checkPassed:
        print "The commit message format check is passed for project {0}.".format(options.project)
        sys.exit(0)
    else:
        print "The commit message format check fails for project {0}.".format(options.project)
        sys.exit(1)
